{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "0a47187d_b35908f5",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 11,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-05-23T16:55:54Z",
      "side": 1,
      "message": "As written, this is going to have LOTS of user-facing impacts if the mapper is no longer considered \"reliable\".  Doing this would mean that we need to add retries in every daemon (like bmcweb), which seems like a lot of complexity that I don\u0027t really want in those daemons.\n\nAs an alternative, what if the interfaces to be added were just added to the InProgressIntrospect object, then when that operation is completed, they would all be added to the global at one time, which I think would avoid your race condition?",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 11,
        "endChar": 13
      },
      "revId": "c804bff683b9ad7fd9743a638a94bc69ce5701f1",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2fb5a441_55548110",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 11,
      "author": {
        "id": 1000044
      },
      "writtenOn": "2022-05-25T08:22:07Z",
      "side": 1,
      "message": "\u003e As written, this is going to have LOTS of user-facing impacts if the mapper is no longer considered \"reliable\". \n\nThis is true. I tried to add this logic in `GetSubTree` method and I did observe services like bmcweb get such exception during BMC startup.\nThat\u0027s why I only add this logic in `GetSubTreePaths` for now.\n\n\u003e As an alternative, what if the interfaces to be added were just added to the InProgressIntrospect object, then when that operation is completed, they would all be added to the global at one time, which I think would avoid your race condition?\n\nI guess this is the pretty much the same as this patch. When it\u0027s in InProgressIntrospect and not available to the `GetSubTreePaths`, it will throw because getSubTreePaths() throws when there is no resource.\n\nAlternatively, could we make getSubTree/Paths() not throw, and only return empty result when the resource is not available?",
      "parentUuid": "0a47187d_b35908f5",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 11,
        "endChar": 13
      },
      "revId": "c804bff683b9ad7fd9743a638a94bc69ce5701f1",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1bf276b0_1530f34a",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 11,
      "author": {
        "id": 1000008
      },
      "writtenOn": "2022-05-26T13:45:14Z",
      "side": 1,
      "message": "I like the idea of just returning an empty result when in progress, which is what would be returned anyway if you called before the introspect started.",
      "parentUuid": "2fb5a441_55548110",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 11,
        "endChar": 13
      },
      "revId": "c804bff683b9ad7fd9743a638a94bc69ce5701f1",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "98500743_0735b75e",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 11,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-05-26T18:24:39Z",
      "side": 1,
      "message": "\u003e That\u0027s why I only add this logic in `GetSubTreePaths` for now.\n\nbmcweb uses GetSubTreePaths as well, so this doesn\u0027t really solve the issue.  FWIW, we need a solution that works for all the mapper methods.\n\n\n\u003e When it\u0027s in InProgressIntrospect and not available to the `GetSubTreePaths`, it will throw because getSubTreePaths() throws when there is no resource.\n\nIMO, it\u0027s very different.  \"This element doesn\u0027t exist yet\" is an error that every implementation already has to handle, because the system might not have that device/path, and in general, doesn\u0027t need to be retried.  \"Can\u0027t give a correct result yet\" errors arguably need to be retried.\n\n\u003e I like the idea of just returning an empty result when in progress,\n\nI think we\u0027re saying the same thing, but we shouldn\u0027t return an EMPTY result, we should just omit the one service being introspected.  Ideally we\u0027d do this by atomically adding all the paths in one shot, when the last handler calls back, instead of adding them as the results come in.  We do this pattern in other contexts like dbus-sensors (admittedly with a timer, but same idea).",
      "parentUuid": "1bf276b0_1530f34a",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 11,
        "endChar": 13
      },
      "revId": "c804bff683b9ad7fd9743a638a94bc69ce5701f1",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ca8e5ec4_bef13891",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 11,
      "author": {
        "id": 1000008
      },
      "writtenOn": "2022-05-26T19:33:26Z",
      "side": 1,
      "message": "\u003e I think we\u0027re saying the same thing, but we shouldn\u0027t return an EMPTY result, we should just omit the one service being introspected.  Ideally we\u0027d do this by atomically adding all the paths in one shot, when the last handler calls back, instead of adding them as the results come in.  We do this pattern in other contexts like dbus-sensors (admittedly with a timer, but same idea).\n\nsounds good to me.",
      "parentUuid": "98500743_0735b75e",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 11,
        "endChar": 13
      },
      "revId": "c804bff683b9ad7fd9743a638a94bc69ce5701f1",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "768defd0_eb055032",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 17,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-05-23T16:55:54Z",
      "side": 1,
      "message": "This is going to force EVERY daemon in openbmc to add retry code for any mapper call.  In terms of complexity, I suspect that\u0027s not what we want.",
      "range": {
        "startLine": 17,
        "startChar": 11,
        "endLine": 17,
        "endChar": 47
      },
      "revId": "c804bff683b9ad7fd9743a638a94bc69ce5701f1",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6b4b07c6_70b7b303",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000044
      },
      "writtenOn": "2022-05-25T08:22:07Z",
      "side": 1,
      "message": "@Ed Possibly let\u0027s discuss the issue in the mailing list to get an agreed solution, and go back to this gerrit to update the code.",
      "revId": "c804bff683b9ad7fd9743a638a94bc69ce5701f1",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d008c716_595382ea",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-05-31T17:00:39Z",
      "side": 1,
      "message": "I thought about this some more, and I really suspect that this is just exposing a design issue in the IPMI logs implementation.\n\nIn terms of using the mapper this way, logs can:\n1. Be created at any time.\n2. Be created by any number of daemons.\n3. Aren\u0027t required by dbus to be created or destroyed in any kind of useful \"order\" given #2\n\nThis means that any code using the mapper needs to handle cases where logs are disjoint, given that that same race condition can occur between daemons, or at the time a log is created.\n\nIf the IPMI implementation can\u0027t handle that, this implies that it has bugs it needs to resolve, or shouldn\u0027t be using the mapper, because it would require guarantees that the mapper can\u0027t give if logs are spread across applications.\n\n\nAnother thing I wonder is would this issue be at least made better by the logging service zero padding their numbered results (ie 0001, instead of 1) such that alphabetically in the dbus sort, entry 2 gets introspected before 11.  Maybe that would give more consistent behavior in terms of \"logs are always added in order for a given daemon\".  There will always be an opportunity for them to be incomplete, but at least they look like they\u0027re append only on startup.\n\n",
      "revId": "c804bff683b9ad7fd9743a638a94bc69ce5701f1",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6962c424_5a22eb9c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2022-05-31T17:34:43Z",
      "side": 1,
      "message": "I wouldn\u0027t be surprised if there are issues in the IPMI logging code, but how did you jump to this even being related to IPMI?  I haven\u0027t seen any previous mention of IPMI.\n\nThe busctl scenario in [1] (from the commit message) shows mapper giving answers of { 47, 375, 851, 1000 }.  The only valid answer was 1000 (and arguably 0).  I 100% agree that applications need to be able to deal with objects coming and going at any point in time, but we should generally at least give causal guarantees.",
      "parentUuid": "d008c716_595382ea",
      "revId": "c804bff683b9ad7fd9743a638a94bc69ce5701f1",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "feeb6b10_15cbd527",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2022-05-31T17:46:05Z",
      "side": 1,
      "message": "\u003e I haven\u0027t seen any previous mention of IPMI.\n\nI guess Lei YU did mention:\n\n\u003e ipmid, the \"cached SEL\" feature depends on the reliable result\n\u003e of GetSubTreePath, to get the number of current logging entries. If\n\u003e it\u0027s not correct, ipmid will not know the \"missed\" entries.\n\nI\u0027m not sure what that means.  Lei YU, can you expand on this?  How would ipmid handle if someone came in over Redfish and deleted an entry in between the mapper query and the phosphor-logging query?",
      "parentUuid": "6962c424_5a22eb9c",
      "revId": "c804bff683b9ad7fd9743a638a94bc69ce5701f1",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aee820c9_2e53fd44",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2022-06-01T02:17:27Z",
      "side": 1,
      "message": "FWIW, some possibly relevant historical background.\n\nOriginally, the python mapper blocked callers while it was introspecting, and it could only introspect one service at a time.  This meant the mapper introspected all services at startup serially, and there were deadlocks between applications starting up and calling the mapper, and the mapper trying to introspect those starting services.\n\nThat had responsiveness issues, so this series added \"non blocking discovery\" which basically returned EBUSY to callers if the mapper was in the middle of introspecting a new service (more or less what Lei Yu has proposed again with this patch):\n\nhttps://gerrit.openbmc.org/c/openbmc/phosphor-objmgr/+/577\n\nThat still had problems though, so we _really_ got creative with this one:\n\nhttps://gerrit.openbmc.org/c/openbmc/phosphor-objmgr/+/2694\n\nThis is where the causal ordering guarantee was dropped from the python mapper generally, but there was still a hacky way to do it for the mapper command line application.\n\nA couple unrelated, half baked thoughts:\n\nWith the c++ mapper being much more responsive, I wonder if it would make sense to go back to blocking callers while it introspects?\n\nWhat about having applications be explicit in informing the mapper they are ready to be introspected?  Something like sd_notify but for the mapper?  Does that help any?",
      "parentUuid": "feeb6b10_15cbd527",
      "revId": "c804bff683b9ad7fd9743a638a94bc69ce5701f1",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d665d31b_4b3d24e9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000044
      },
      "writtenOn": "2022-06-01T02:21:56Z",
      "side": 1,
      "message": "\u003e If the IPMI implementation can\u0027t handle that, this implies that it has bugs it needs to resolve, or shouldn\u0027t be using the mapper, because it would require guarantees that the mapper can\u0027t give if logs are spread across applications.\n\nThe ipmid SEL cache handler handles the above cases well. The issue occurs on BMC boot when ipmid and phosphor-logging are starting, where mapper gives incomplete result.\n\n\u003e Another thing I wonder is would this issue be at least made better by the logging service zero padding their numbered results (ie 0001, instead of 1) such that alphabetically in the dbus sort, entry 2 gets introspected before 11.  Maybe that would give more consistent behavior in terms of \"logs are always added in order for a given daemon\".  There will always be an opportunity for them to be incomplete, but at least they look like they\u0027re append only on startup.\n\nYes this is a bug in phosphor-logging where it uses the `filesystem order` to create the entries. This bug is not related to the \"mapper incomplete result\" though.\n\n\u003e The busctl scenario in [1] (from the commit message) shows mapper giving answers of { 47, 375, 851, 1000 }.  The only valid answer was 1000 (and arguably 0).\n\nThis is exactly the issue here.\n\n\u003e I\u0027m not sure what that means.  Lei YU, can you expand on this?  How would ipmid handle if someone came in over Redfish and deleted an entry in between the mapper query and the phosphor-logging query?\n\nThe mapper query happens only on ipmid\u0027s startup. When it\u0027s done, it only gets interfacesAdded/Removed or propertiesChanged signal callbacks.",
      "parentUuid": "feeb6b10_15cbd527",
      "revId": "c804bff683b9ad7fd9743a638a94bc69ce5701f1",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "85198cd1_9e047274",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000044
      },
      "writtenOn": "2022-06-01T02:27:12Z",
      "side": 1,
      "message": "\u003e With the c++ mapper being much more responsive, I wonder if it would make sense to go back to blocking callers while it introspects?\n\nI guess no. It takes quite a few seconds if a service has many objects to introspect, and blocking a caller for a few seconds is not a good idea.\n\n\u003e What about having applications be explicit in informing the mapper they are ready to be introspected?  Something like sd_notify but for the mapper?  Does that help any?\n\nIn the phosphor-logging case, it is ready for mapper to introspect, it just takes mapper a few (or maybe more than ten if BMC is busy) seconds to introspect. And during this, the mapper gives incomplete result when the introspect is ongoing.",
      "parentUuid": "d665d31b_4b3d24e9",
      "revId": "c804bff683b9ad7fd9743a638a94bc69ce5701f1",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "32706205_184cb19c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000008
      },
      "writtenOn": "2022-06-01T13:52:47Z",
      "side": 1,
      "message": "What\u0027s wrong with Ed\u0027s proposal of just having mapper not add the new interfaces/paths into \u0027the Map\u0027 until the InProgressIntrospect destructor?",
      "parentUuid": "85198cd1_9e047274",
      "revId": "c804bff683b9ad7fd9743a638a94bc69ce5701f1",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c19837a2_5864f84f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2022-06-01T18:34:08Z",
      "side": 1,
      "message": "\u003e What\u0027s wrong with Ed\u0027s proposal of just having mapper not add the new interfaces/paths into \u0027the Map\u0027 until the InProgressIntrospect destructor?\n\nNothing that I can tell.  I missed it initially.",
      "parentUuid": "32706205_184cb19c",
      "revId": "c804bff683b9ad7fd9743a638a94bc69ce5701f1",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8997c07a_be237423",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-06-01T21:58:42Z",
      "side": 1,
      "message": "\u003e I wouldn\u0027t be surprised if there are issues in the IPMI logging code, but how did you jump to this even being related to IPMI?  I haven\u0027t seen any previous mention of IPMI.\n\nOn the mailing list, it was reported that this interfered with the \"sel cache\" feature, which I don\u0027t have any idea what it is, but I\u0027m assuming is trying to cache log entries in the ipmi daemon.\n\n\u003e The only valid answer was 1000 (and arguably 0).  \n\nI\u0027m assuming the objects in the logger are added one at a time (I don\u0027t know of how to \"batch add\" objects in objectmanager), so the numbers between 0-1000 are valid, and could occur anyway if I just added logs while the thing was starting up, right?\n\n\n\u003e With the c++ mapper being much more responsive, I wonder if it would make sense to go back to blocking callers while it introspects?\n\nI don\u0027t think this flies, as it makes the mapper only as fast as the slowest-to-introspect client, and there are some SLOOOOOOOOW clients out there that do blocking io in the event loop, so I\u0027m not sure that works.\n\n\n\u003e The ipmid SEL cache handler handles the above cases well. The issue occurs on BMC boot when ipmid and phosphor-logging are starting, where mapper gives incomplete result.\n\nCan you elaborate on this some more?  The \"incomplete\" result would look the same as log entries being added to the system, right?\n\n\n\u003e Yes this is a bug in phosphor-logging where it uses the `filesystem order` to create the entries. This bug is not related to the \"mapper incomplete result\" though.\n\nThis seems like the core of the problem here.  If phosphor-logging on startup is creating entries in a randomized order (creates object id 1, then 11, then 2, ect) then there isn\u0027t much the mapper can do to give a \"complete\" result at any given point in time, right?  Can we start by getting that bug fixed, and see if that helps?\n\n\n\u003e The mapper query happens only on ipmid\u0027s startup. When it\u0027s done, it only gets interfacesAdded/Removed or propertiesChanged signal callbacks.\n\nThe way this is described, you\u0027re duplicating mapper functionality in ipmi?  This seems like the core of the problem.  The mapper listens on InterfacesAdded/Removed, and keeps the list up to date, avoiding as many race conditions as it\u0027s able.  The expectation is that ipmi would call the mapper anytime it needs the data on available paths.\n\n\n\n\n\nIf we want to make the initial add of objects atomic like I proposed, I guess I\u0027m ok with it, as it helps for other things and makes things appear more sane, but the way this feature is described, and how phosphor-logging seems to be implemented (adding logs in randomized order) seem like design issues that should be fixed in their respective daemons.",
      "parentUuid": "c19837a2_5864f84f",
      "revId": "c804bff683b9ad7fd9743a638a94bc69ce5701f1",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4a39a415_ad90aab7",
        "filename": "src/main.cpp",
        "patchSetId": 1
      },
      "lineNbr": 27,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-05-23T21:48:46Z",
      "side": 1,
      "message": "I don\u0027t think this can be a set.  In theory, a process can be in introspect multiple times.",
      "range": {
        "startLine": 27,
        "startChar": 12,
        "endLine": 27,
        "endChar": 15
      },
      "revId": "c804bff683b9ad7fd9743a638a94bc69ce5701f1",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "33e2b4d9_0844577b",
        "filename": "src/main.cpp",
        "patchSetId": 1
      },
      "lineNbr": 27,
      "author": {
        "id": 1000044
      },
      "writtenOn": "2022-05-25T08:22:07Z",
      "side": 1,
      "message": "OK, we could use unordered_multiset\u0027s insert() and extract() instead.",
      "parentUuid": "4a39a415_ad90aab7",
      "range": {
        "startLine": 27,
        "startChar": 12,
        "endLine": 27,
        "endChar": 15
      },
      "revId": "c804bff683b9ad7fd9743a638a94bc69ce5701f1",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}